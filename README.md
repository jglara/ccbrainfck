# ccbrainfck

Brainfuck interpreter and bytecode VM implemented as a modern CMake project inspired by the [codingchallenges.fyi Brainfuck challenge](https://codingchallenges.fyi/challenges/challenge-brainfuck).

## Project Structure
- `CMakeLists.txt` / `CMakePresets.json` &mdash; configure the CMake build, toolchain presets, and optional tooling hooks (clang-tidy, ccache).
- `include/bytecode.hpp` &mdash; declares the intermediate bytecode instructions.
- `include/bfcompiler.hpp` &mdash; exposes the Brainfuck-to-bytecode compiler and helpers.
- `include/bfvm.hpp` &mdash; defines the bytecode virtual machine used by the compiled executable.
- `include/ccbf.hpp` &mdash; contains the direct interpreter (`BFMachine`) that runs source programs.
- `src/bfcompiler.cpp` &mdash; optimizer and jump-resolution logic backing the compiler.
- `src/main.cpp` (`ccbf`) &mdash; CLI entry point for the classic interpreter with an interactive REPL.
- `src/compiler.cpp` (`ccbfvm`) &mdash; CLI entry point that compiles Brainfuck to bytecode and executes it via the VM.
- `test/` &mdash; GoogleTest suites covering the interpreter and compiler plus sample Brainfuck programs (`helloworld.bf`, `mandelbrot.bf`).
- `build/` &mdash; default out-of-source build directory generated by CMake (safe to delete/recreate).

## Configure, Build, and Test
Use the provided CMake presets from the repository root:

- **Debug build** (instrumented binaries, default preset):  
  `cmake --preset debug`  
  `cmake --build --preset debug`  
  `ctest --preset debug --output-on-failure`

- **Release build** (optimized binaries for benchmarking):  
  `cmake --preset release`  
  `cmake --build --preset release`  
  `ctest --preset release --output-on-failure`

Both presets generate their own build directory under `build/` (for example `build/debug`). Remove a preset directory if you need a clean reconfigure.

## Running the Interpreters
- **Interpreted mode (`ccbf`)**  
  Build with the desired preset and run either interactively or from a file:  
  `cmake --build --preset debug --target ccbf`  
  `./build/debug/ccbf` &mdash; starts a REPL (`CCBF>` prompt).  
  `./build/debug/ccbf path/to/program.bf` &mdash; executes the source file directly.

- **Compiled bytecode mode (`ccbfvm`)**  
  Build and supply a program plus optimization level (`0`, `1`, or `2`):  
  `cmake --build --preset debug --target ccbfvm`  
  `./build/debug/ccbfvm path/to/program.bf 2`  
  This path runs the optimizer, emits bytecode, and executes it on the virtual machine.

Both executables read standard input for the `,` command and stream output to standard output so you can pipe data as needed. Delete the `build/` directory to produce a fresh configuration if you switch toolchains.

## Sample Brainfuck Programs
- `test/helloworld.bf` prints a multi-line greeting and punctuation. It is useful for smoke-testing both binaries:  
  `./build/debug/ccbf test/helloworld.bf`  
  `./build/debug/ccbfvm test/helloworld.bf 2`

- `test/mandelbrot.bf` computes an ASCII Mandelbrot set. The program is intentionally heavy and highlights the difference between the interpreted and compiled execution paths.

## Timing the Mandelbrot Example
For meaningful benchmarks, prefer the release preset:

1. Build the optimized binaries:  
   `cmake --build --preset release --target ccbf ccbfvm`
2. Run the interpreter and VM with the shell `time` command, discarding the voluminous fractal output:  
   ```bash
   time ./build/release/ccbf test/mandelbrot.bf >/dev/null
   time ./build/release/ccbfvm test/mandelbrot.bf 0 >/dev/null   # no compiler optimizations
   time ./build/release/ccbfvm test/mandelbrot.bf 1 >/dev/null   # collapsed add/move sequences
   time ./build/release/ccbfvm test/mandelbrot.bf 2 >/dev/null   # full optimizations (zeroing loops)
   ```

The `time` output reports:
- `real`: wall-clock duration from start to finish.
- `user`: CPU time spent in user mode (Brainfuck execution).
- `sys`: CPU time spent in kernel mode (I/O, process overhead).

You should observe `real`/`user` shrink as you move from the interpreter to the bytecode VM, and further as you increase the optimization levelâ€”`ccbfvm` at level 2 benefits from both arithmetic collapsing and loop zeroing, making Mandelbrot the fastest of the variants.
